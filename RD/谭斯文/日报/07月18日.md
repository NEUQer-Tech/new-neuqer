# 个人日报

谭斯文 202112053

#### 本日工作：

1. 继续学习了计网的传输层

#### 成果展示：

3.4 TCP可靠传输
TCP是提供可靠传输，UDP这种本身还是不可靠传输的就再靠应用层解决了


3.4.1 序号
就是TCP根据下方数据链路层的MTU（最大传输单元）来随即将数据切割成好几端并且进行编号


3.4.2 确认
发送方每一次发送数据之后都需要接收方进行确认。
TCP使用的是累计确认机制，就是从第一个丢失的字节开始请求丢失的报文段。如图中456丢失，78到达，但仍然请求发送的数据序号是4


3.4.3 重传
为什么要使用自适应算法？网络环境太复杂，路径又长又短，RTT设置短了照顾不了距离远的，RTT设置长了又导致网络利用率降低，所以使用RTTs



3.5 TCP流量控制
简单来说就是接收方可以动态的发送信息告诉发送方发送窗口的大小。
接收方接受不过来了就让发送方发送窗口小点，这样发送方发送的速率就慢下来了，接收方就有时间处理它的数据了
接受方处理完了也可以发送请求让发送方发送窗口大点，这样发送方发送的速率就快起来了，接收方就可以处理更多数据而不是空闲等着收数据了


3.5.1 计时器
在本例子中，使用的累计确认机制（一次回复收到ack=201）和三次流量控制机制。
但是有一个情况就是，如果最后B不允许A再发送数据了，B在处理完数据之后想要恢复窗口大小时发送的有rwnd大小的数据报丢了怎么办？此时A有B的指令在前，发送窗口为0无法发送数据，B也在等待A回复，造成了类似死锁的现象
解决方法：使用计时器


3.6 TCP拥塞控制
流量控制是对单独一个来说的，拥塞控制是一群


3.6.1 拥塞控制四种算法
这里虽然是四种算法，但是通常是两两结合进行使用


3.6.2 慢开始和拥塞避免
这里开始时以指数形式增长，ssthresh的意思是慢开始门限，代表从这个地方注入的报文段就比较多了，需要开始慢速增加了。
之后一段都是线性增长，每次增加1，直至达到网络拥塞状态
瞬间将cwnd设置为1，同时调整原来的ssthresh的值到之前达到网络拥塞状态的1/2,（这里是24降到12）
重复以上步骤，但是注意此时ssthresh变了之后线性增长的转折点也变了


3.6.3 快重传和快恢复
这里和上面的慢开始和拥塞避免的一开始步骤差不多，都是先指数增长再转变为线性增长。
不同的点是快重传和快恢复算法是在收到连续的ack确认之后执行，这里的ack就是冗余ack，冗余ack的特点是如果多次对某一段请求的数据没有被收到，达到一定数目之后就会立即执行重传。但是此时只是降到现在cwnd的一半，再重新线性增长。而不是像慢开始和拥塞避免的从头开始


4. 传输层常见题目收集
   4.1. TCP、UDP区别及使用场景
   TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。
   TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。TCP通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。
   UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。
   每一条TCP连接只能是点到点的；UDP支持一对一、一对多、多对一和多对多的交互通信。
   TCP对系统资源要求较多，UDP对系统资源要求较少。

4.2 TCP两次握手可以吗？
第三次握手主要为了防止已失效的连接请求报文段突然又传输到了服务端，导致产生问题。
比如客户端A发出连接请求，可能因为网络阻塞原因，A没有收到确认报文，于是A再重传一次连接请求。
连接成功，等待数据传输完毕后，就释放了连接。
然后A发出的第一个连接请求等到连接释放以后的某个时间才到达服务端B，此时B误认为A又发出一次新的连接请求，于是就向A发出确认报文段。
如果不采用三次握手，只要B发出确认，就建立新的连接了，此时A不会响应B的确认且不发送数据，则B一直等待A发送数据，浪费资源。

4.3 第四次挥手为什么要等待2MSL？
1.保证A发送的最后一个ACK报文段能够到达B。
这个ACK报文段有可能丢失，B收不到这个确认报文，就会超时重传连接释放报文段，然后A可以在2MSL时间内收到这个重传的连接释放报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入到CLOSED状态，若A在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到B重传的连接释放报文段，所以不会再发送一次确认报文段，B就无法正常进入到CLOSED状态。
2.防止已失效的连接请求报文段出现在本连接中。
A在发送完最后一个ACK报文段后，再经过2MSL，就可以使这个连接所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现旧的连接请求报文段。

4.4 如果 1、2、3 次握手分别丢包了，会发生什么？
第一次客户端发的 SYN 丢了：
客户端迟迟接不到响应，超时重传。

第二次服务端发的 SYN 和 ACK 丢了
客户端迟迟接不到响应，超时重传

第三次客户端发的 ACK 丢了？
因为第三次发完 ACK 之后，随时接下来会继续往服务端发数据，我看过一篇博客里写的是发数据时会带上 ACK，所以客户端响应的 ACK 包丢了，服务器也能够通过之后的包来建立连接。

第三次故意不发送 ACK 呢？
洪水攻击，服务器在等待第三次握手时是处于半连接状态，也是需要耗费资源的，如果有攻击者故意不发送第三次 ACK，让大量连接处于半连接状态，那么会把服务器资源耗尽，洪水攻击的目的就达到了。