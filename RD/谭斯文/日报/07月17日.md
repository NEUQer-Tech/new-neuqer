# 个人日报

谭斯文 202112053

#### 本日工作：

1. 了解并学习了计网的传输层

#### 成果展示：

## 概述

1.1 传输层的意义
传输层的由来
有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。
接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？
也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。
“端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。
“传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做”套接字”（socket）。有了它，就可以进行网络应用程序开发了。

网络层可以把数据从一个主机传送到另一个主机，但是没有和进程建立联系；传输层就是讲进程和收到的数据联系到一起，使数据能够为应用服务
所以说传输层是主机才有的层次


1.2 传输层的两个协议


1.3 传输层的寻址和端口
端口号只用于计算机分辨本地进程，总共有2^16=65536种端口号，端口号有很多种，不能随便使用


1.3.1 常见的应用程序端口号


2. UDP协议
   2.1 UDP概述
   注释：
   因为UDP一次发送一个完整报文不会分片，所以需要应用层传输过来的数据不要太大，否则网络层分片任务就很重，但是也不能太小，不然效率较低
   UDP适合一些实时应用，因为实时应用延迟要求高，需要立即响应


2.2 UDP首部格式


2.2.1 UDP的校验位构成
这里的伪首部只是用来计算检验和的，计算完了就丢弃，可以见下UDP的校验方式


2.2.2 UDP校验方式
总结一下步骤：
在发送端的时候：
1.就是将每一行（4字节）拆成两部分，左右平均2字节大小，将这两字节数据写成二进制，那么2字节一共就需要2*8=16位。此时检验和没有计算，默认填充0，同时如果数据字段不整齐，则用0补齐，这样就可以写出几十行二进制数，如图中方所示
2.计算着几十行二进制数按二进制反码运算求和，二进制反码运算可以参考
二进制反码求和运算
得到的最后简介再反码，之后将反码之后的放入原来的检验和字段

在接收端的时候
与发送端的时候不同的是，此时检验和字段不是0了
按照发送端的步骤再将所有数据写成二进制进行二进制反码运算求和
如果最后得到结果全1就是没问题，否则丢弃


2.3 UDP补充
1.UDP怎么保证能收到数据？
UDP将可靠传输的实现放到了应用层，然后类似于TCP，实现确认机制，重传机制
UDP不属于连接型协议，因而具有消耗资源小，处理速度快等优点，所以通常音频、视频通话在传送时使用UDP比较多，因为它们即使丢失一两个数据包也不会对结果产生太大影响
UDP传输层无法保证数据的可靠传输，只能通过应用层来实现了；实现的方式可以参考TCP可靠传输的方式，只是实现不在传输层，转移到了应用层
目前有如下开源程序利用UDP实现了可靠的数据传输；分别有RUDP, RTP, UDT

3. TCP协议
   3.1 TCP协议的特点
   TCP必须要建立连接之后才可以进行数据交换，所以TCP是面向连接的

TCP传输数据是随机切割数据的

3.2 TCP报文段的首部
注释：
见上图，可以看到TCP是将数据随机分割后加上TCP头传输的，所以
序号就是为了标记这些随机分割之后的数据，这里把第一个字节的编号当成序号
确认号就是收到之后做一下标记，代表这之前的都收到了，希望收到的下一个编号的数据就是确认号打头的那个数据
偏移量就是为了标记一下距离TCP开始多少字节是数据，这里的单位是4B，这个偏移量就是TCP首部长度

窗口就是接收方告诉发送方，还有多少地方（缓存）可以放数据
紧急指针就是告诉TCP从哪里到哪里是紧急数据


3.2.1 TCP的六个控制位
紧急位URG
URG的特点就是让数据插队，URG=1的就会在缓存中被提前到第一个传输



确认位ACK


推送为PSH
就是接收端的URG，将PSH=1的数据尽快接收
注意一下，如果没有PSH，一般都是接收方缓存满了之后再将数据发送到主机


复位RST


同步位SYN
A和B主机要建立连接，就A先发一个报文，其中SYN=1
B收到之后也回复一个SYN=1的报文，代表接受连接


终止位FIN


3.3 TCP连接管理
3.3.1 TCP三次握手（建立连接）
名称	作用
SYN	同步序号，用于建立连接过程，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1
FIN	用于释放连接，为1时表示发送方没有发送了
ACK	为1表示确认号有效，为0表示报文不含确认信息，忽略确认号字段，上面的确认号是否有效就是通过该标识控制的
ack	是期望收到对方下一个报文段的第一个数据字节的序号
seq	TCP连接中传送的字节流中的每个字节都按顺序编号
注释：
第一段的意思是
SYN同步序号=1：(A)要建立连接了！
seq序号=x（随机）：因为还没有数据，所以写什么都无所谓

第二段的意思是
SYN同步序号=1：我(B)同意你(A)建立连接！
ACK确认序号=1：连接建立了，之后的ACK必须都置为1
seq序号=y（随机）：因为还没有数据，所以写什么都无所谓
ack确认号=x+1：之前发送方(A)说发送的是第x位数据（虽然发送方是瞎说的），所以我(B)要的是x+1位数据

第三段的意思是
SYN=0：SYN只有在建立连接时才为1，其他时候均设为0
ACK=1：连接建立了，之后的ACK必须都置为1
seq=x+1：我(A)发送的报文段的第一个字节就是x+1
ack=y+1：之前接收方(B)说发送的是第y位数据（虽然接收方是瞎说的），所以我(A)要的是y+1位数据

注意一下，TCP是双向的，所以不存在绝对不变的发送方接收方，这里的两台主机都同时是发送方和接收方


TCP三次握手特定导致的SYN洪泛攻击


3.3.2 TCP四次挥手（连接释放）
名称	作用
SYN	同步序号，用于建立连接过程，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1
FIN	用于释放连接，为1时表示发送方没有发送了
ACK	为1表示确认号有效，为0表示报文不含确认信息，忽略确认号字段，上面的确认号是否有效就是通过该标识控制的
ack	是期望收到对方下一个报文段的第一个数据字节的序号
seq	TCP连接中传送的字节流中的每个字节都按顺序编号
注释：
第一段的意思是
FIN=1：(A)要释放连接了！
seq=u：发了好多数据，这里只是用u指代一下，这里u是有确定值的

第二段的意思是
ACK=1：连接建立了，之后的ACK必须都置为1
seq=v：发了好多数据，这里只是用v指代一下，这里v是有确定值的
ack=u+1：之前发送方(A)说发送的是第u位数据，所以我(B)要的是u+1位数据（尽管此时A已经决定释放连接了）

第三段的意思是
FIN=1：(B)要释放连接了！
ACK=1：连接建立了，之后的ACK必须都置为1
seq=w：发了好多数据，这里只是用w指代一下，这里w是有确定值的
ack=u+1：之前发送方(A)说发送的是第u位数据，所以我(B)要的是u+1位数据（因为A直接不发数据了，所以第二段第三段的ack都是u+1）

第四段的意思是
ACK=1：连接建立了，之后的ACK必须都置为1
seq=u+1：之前发的数据时第u位数据，B也要第u+1位数据，所以我发第u+1位数据
ack=w+1：之前发送方(B)说发送的是第w位数据，所以我(A)要的是w+1位数据

为什么需要等待计时2MSL？
因为这样可以保证B可以收到A的终止报文段进而进入关闭状态
比如说如果A的第四段报文丢失，那么等待一个MSL之后B就会重传第三段报文，花费小于1MSL之后A就会再收到第三段报文，之后就可以再次向B发送第四段报文提示B关闭连接