# 日报

*到后期都是比较简略的记录*

笔记部分在知识库：

博客页：[鹏程 · 语雀 (yuque.com)](https://www.yuque.com/pengcheng-ntssk)

知识库：https://www.yuque.com/books/share/4f55df40-20e7-47d9-89d0-b08b2557b7bc?# 《前端学习》密码：qkwx

- 第一天

  - 算法学习：学习（也算复习）了二分查找和二分搜索

    - 具体的：

      - 三种二分

        - 查值之后返回

        - 查找左边界

        - 查找右边界

      - 二分搜索

        - 一般是求最大的最小值（这里是指两个不同的值函数的最大最小）或者最小的最大值

        - 一般的实现步骤

          - 找到一组量和一个函数----构造二分搜索

          - 确定边界，也就是 left right 的值

          - 构造一个单调函数，用来判断二分搜索的结果是否符合条件

          - 明确判断之后的二分搜索的方向---当符合条件的时候应该往哪一边收缩（这里是边界的二分）

  - 重学前端

    - 第零部分

      - 前端概述

        - 前端的历史

          - 静态页面

          - 动态页面

          - 组件化+复杂前端应用

          - ....

        - 前端学习的问题

          - 资料比较少，不够系统

          - 工程师的水平差距非常大--知识不够系统，能力难以提升

        - 前端的方法论

          - 一是立足标准，系统性总结和整理前端知识，建立自己的认知和方法论；

          - 二是放眼团队，从业务和工程角度思考前端团队的价值和发展需要。只有这样做，才能够持续发展，在高速发展的技术和工程浪潮中稳稳立足。

      - 明确学习方法和路线

        - 学习方法

          - \1. 建立自己的知识体系--逻辑性和完备性

            - js

              - 文法

              - 语义

              - 进行时

          - \2. 追本溯源
            - 关注技术提出的背景和应用场景----了解一个技术的最佳实践

      - 前端的知识体系架构

        - javascript
          - 架构图![img](https://api2.mubu.com/v3/document_image/98d3ec57-c93c-42e0-981f-e3254fc0c3ae-13258694.jpg)

        - html

          - 文档元信息：通常是出现在 head 标签中的元素，包含了描述文档自身的一些信息；

          - 语义相关：扩展了纯文本，表达文章结构、不同语言要素的标签；

          - 链接：提供到文档内和文档外的链接；

          - 替换型标签：引入声音、图片、视频等外部元素替换自身的一类标签；

          - 表单：用于填写和提交信息的一类标签；

          - 表格：表头、表尾、单元格等表格的结构。

        - css

          - 布局

          - 绘制

          - 交互

        - 浏览器的实现原理

          - 设计思想

          - 常见api

        - 前端工程实践
          - ![img](https://api2.mubu.com/v3/document_image/b696ef65-3722-4ce0-9fc5-26b4f832e7ee-13258694.jpg)

        - ![img](https://api2.mubu.com/v3/document_image/bb30b04a-3b6d-4240-9487-f36429895097-13258694.jpg)

    - 第一部分---js

      - 类型

        - 问题引入

          - 为什么有的编程规范要求用 void 0 代替 undefined？

          - 字符串有最大长度吗？

          - 0.1 + 0.2 不是等于 0.3 么？为什么 JavaScript 里不是这样的？

          - ES6 新加入的 Symbol 是个什么东西？

          - 为什么给对象添加的方法能用在基本类型上？

        - 七大类型

          - Undefined；

          - Null；

          - Boolean；

          - String；

          - Number；

          - Symbol；

          - Object

        - null  and  undefined

          - 这里引出来的是 undefined  和  void 0 的区别，原因是：undefined 是一个变量,可以修改它的值（不过我在node里面发现并不能修改，可能是标准修复了),而 使用 void 0 的操作一定能够得到 undefined 的值，可以避免在使用的时候给变量错赋undefined

          - 而 null 只有一个值 ， 就是 null ，可以放心使用

        - string

          - 编码：unicode 是标准 ，而UTF8和UTF16是编码的实现，常用的字符有一个基本命名空间

          - js中的string长度是指 UTF16的编码长度，而不是我们常常理解的编码长度。

          - 当我们开发过程中使用到了 基本命名空间之外的字符时，需要注意，防止string 类型出现错误

        - Number

          - js中的数字类型使用的是双精度标准，提供了NaN,infinity,-infinity 三个特殊的数。

          - 小数之间的比较不能使用 ==(===也不行),而应该使用js提供的最小精度(EPSION)

          - 在处理和0相除的时候要注意符号：infinity 和 - infinity 是不相等的

        - Symbol

          - 一切非字符对象 key 的集合

          -  var s = new Symbol("name") 创建一个symbol对象的方法

        - Object

          - 一切的类型在运行时中都是 object 的私有属性----一切皆对象

          - 类型转换---一般都有拆箱和装箱的过程

          - 拆箱和装箱是可以自定义的

          - call方法---在这个对象的方法中使用另一个对象中的属性，属性在被使用的时候会自动进行类型的包装

      - 对象

        - 面向对象

          - 对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。

          - 对象有状态：对象具有状态，同一对象可能处于不同状态之下。

          - 对象具有行为：即对象的状态，可能因为它的行为产生变迁。

        - 数据属性

          - value：就是属性的值。

          - writable：决定属性能否被赋值。

          - enumerable：决定 for in 能否枚举该属性。

          - configurable：决定该属性能否被删除或者改变特征值。

        - 访问器属性

          - getter：函数或 undefined，在取属性值时被调用。

          - setter：函数或 undefined，在设置属性值时被调用。

          - enumerable：决定 for in 能否枚举该属性。

          - configurable：决定该属性能否被删除或者改变特征值。

        - 实际上 JavaScript 对象的运行时是一个“属性的集合”，属性以字符串或者 Symbol 为 key，以数据属性特征值或者访问器属性特征值为 value

        - 我们应该在理解其设计思想的基础上充分挖掘它的能力，而不是机械地模仿其它语言。

- 第二天

  - 重学前端

    - 关于js中的两种面向对象的编程范式

      - \1.  原型

        - 主要关键字

          - Object.create 根据指定的原型创建新对象，原型可以是 null；

          - Object.getPrototypeOf 获得一个对象的原型；

          - Object.setPrototypeOf 设置一个对象的原型。

        - 创建对象的过程

          - 以构造器的 prototype 属性（注意与私有字段 [[prototype]] 的区分）为原型，创建新对象；

          - 将 this 和调用参数传给构造器，执行；

          - 如果构造器返回的是对象，则返回，否则返回第一步创建的对象。

        - ![img](https://api2.mubu.com/v3/document_image/3dbc0e08-2081-45f7-ad8a-a1973352e2a8-13258694.jpg)

      - \2.  类

        - 在es6中可以直接使用和java、c++基本相同的类的对象方法

        - 基本语法

          - class ----定义一个类的关键字

          - constructor ----类的构造函数，数据部分一般放在这个里面

          - set/get----用来设置对象的 getter和setter

          - 使用 name function(){}的方式来定义函数

          - extend --- 继承

          - super  --- 在子类中调用父类的构造函数

        - 一个应用实例![img](https://api2.mubu.com/v3/document_image/a98235c9-1af9-4416-87f6-13fb438a4a7a-13258694.jpg)

  - vue3学习

    - 基础

      - 模板语法

        - 插值

          - {{}}

          - v-bind

          - v-html

          - 注意：在{{}}中只能绑定一个js表达式，复杂的，如函数等是无法解析的

        - 指令

          - 指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于DOM

          - v-if --根据绑定属性的真假来插入或者移除元素

          - v-bind ---用于响应式的更新数据

          - v-on --- 监听DOM中的事件

        - 动态参数
          - 格式：v-bind:[attributename]='url'这里的attributename如果存在于我们的 data()中，就会使用我们data中为它配置的数据

        - 修饰符
          - 用于指定指令绑定的方式，如 .prevent === event.preventDefault();也就是阻止默认事件

        - 缩写

          - v-bind === :

          - v-on === @

        - 注意

          - 使用绑定的指令绑定一个null可以移除指令

          - 在dom中使用模板的时候 html 会将大写的动态属性转化为小写的，这点需要注意

      - data 

        - Vue 会在创建新组件实例的过程中调用此函数。它应该返回一个对象，然后 Vue 会通过响应性系统将其包裹起来，并以 $data 的形式存储在组件实例中。

        - 数据只会在这个vm创建的时候添加，如果有没有值的属性，应该使用占位符--null，undefined

      - method

        - vue 自动为 method 函数绑定了this,指向组件实例

        - method 定义的函数可以在任何可以使用js表达式的地方使用

        - 防抖和节流没有内置，但是可以使用第三方的库实现

          - 直接在method中使用

          - 在生命周期函数中进行包装---提高组件的复用性

      - computed

        - 计算属性是用来抽象出一些比较复杂的计算操作

        - 给computed函数添加的函数属性会自动添加到VM上，可以给它设置getter and setter，可以在setter中为数据做一些处理

        - 计算属性和method的本质都是函数，一般情况下两者的作用效果没有区别，但计算属性有缓存，只在它依赖的数据更新的时候更新，在一些场景中可以有效的提升性能

      - watch

        - 适用于大量异步操作或者开销较大的操作

        - 在watch中可以根据数据的变化来执行异步操作，而计算属性中不能这么做

        - 注意：虽然watch的功能更广，但是有时候使用 computed 属性更加简便

      - class 和 Style 绑定

        - 对象

        - 数组--可以在里面使用三元表达式

        - 静态给定

        - 其中数组中可以嵌套对象

  - 算法

    - 再复习一下步骤

      - \1. 题目需要求的量 x ，并找出x 和题目给出的约束量之间的关系，表达为一个单调函数

      - \2. 找到 左右边界，这个一般和给我们的数据有关，一般是数组的最大值或者最小值，亦或者数组的和

      - \3. 二分查找，这里需要注意的是区间的收缩方向和我们的函数的性质有关系，可能是找左边界，也有可能是有边界

    - 继续两道二分搜索

      - [1011. 在 D 天内送达包裹的能力](https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/)
        - ![img](https://api2.mubu.com/v3/document_image/b647ed42-e8db-45b4-9a54-b219d0f33ed5-13258694.jpg)

      - [410. 分割数组的最大值](https://leetcode.cn/problems/split-array-largest-sum/)
        - 这两道题解答是一样的，抽象的问题分析果然要比具体的问题难得多![img](https://api2.mubu.com/v3/document_image/87944ec3-8eb1-4f0c-b134-a7a8e2e7b005-13258694.jpg)

- 第三天

  - 重学前端

    - JS中的对象

      - 宿主对象
        - 由宿主环境提供，常见的有Node和浏览器提供的对象

      - 内置对象

        - 固有对象(intrinsic object)---在运行时会自动创建的对象

        - Native Object ---感觉英文的更好理解，js内置功能的对象，如正则、错误对象等，一般难以通过自己实现

        - Ordinary Object ---用户自己创建的对象等

      - 对象的 Call 和 constructor

        - js中可以使用 call 方法来让对象模拟函数，在我理解就是传入一个对象，然后call使用里面的参数来执行函数对象的方法，或者直接使用对象名来作为函数进行调用。

        - 一些内置对象的 call 方法和 constructor 是不一样的

      - 一些特殊对象的特殊行为

        - Array：Array 的 length 属性根据最大的下标自动发生变化。

        - Object.prototype：作为所有正常对象的默认原型，不能再给它设置原型了。

        - String：为了支持下标运算，String 的正整数属性访问会去字符串里查找。

        - Arguments：arguments 的非负整数型下标属性跟对应的变量联动。

        - 模块的 namespace 对象：特殊的地方非常多，跟一般对象完全不一样，尽量只用于 import 吧。

        - 类型数组和数组缓冲区：跟内存块相关联，下标运算比较特殊。

        - bind 后的 function：跟原来的函数相关联。

  - 算法

    - 田忌赛马问题

      - \1. 用自己这边最强的和对面最强的比

        - 如果赢了，那就不用调换顺序

        - 如果输了，那就拿我们这边最菜的和他换

      - \2. 执行以上步骤，直到结束

      - 注意点：这道题思想是比较简单的，实现的时候用到了java的优先队列，需要熟悉一下语法

      - ![img](https://api2.mubu.com/v3/document_image/9c1721e8-7b58-4eb5-a3c9-fdbb44f5a7bc-13258694.jpg)

  - vue3

    - 条件渲染

      - v-if

        - 可以使用 template实现一次渲染多个元素

        - 会真的创建和销毁元素

        - 有比较高的切换开销

      - v-show

        - 元素不会真正的消失，而是在第一次渲染之后随着css的切换而切换

        - 有比较高的初渲染开销

    - 列表渲染

      - 使用v-for='item in items'来进行数组中元素的渲染

      - 还可以使用 v-for来遍历对象中的指，遍历的结果和object.keys()遍历的结果相同

      - 可以数组遍历的时候可以传入第二个参数,index，获取索引，而对对象的遍历则可以传入三个参数(item, key,index);

      - 我们还可以在组件标签上使用v-for,不过这种方式需要指定props来进行接收

      - 维护状态
        - vue中进行的数据更新是就地更新，一般来说比较高效，但是如果出现了表单元素的变化的时候就容易出问题（元素变了，数据还在原来的位置），这个时候就需要指定一个key的值，防止出现意料之外的错误

      - 数组更新检测

        - vue对几个常用的数组方法进行了包裹，使用它们的时候也会触发视图的更新

          - push()

          - pop()

          - shift()

          - unshift()

          - splice()

          - sort()

          - reverse()

        - 在使用不修改原数组的方法时，我们可以使用返回的新数组替换原数组，如filter concat slice这几个方法

        - 在需要对元素进行筛选的时候，我们也可以使用计算属性来进行筛选---可以部分的替换原来的过滤器的功能

        - v-for 可以嵌套使用

        - 可以在<template>中使用 v-for

    - 事件检测
      - 

- 第四天

  - 重学前端

    - 语义化标签

      - 优点

        - 对我们开发人员更友好，可以方便的看出页面的结构

        - 对SEO更友好

      - 缺点
        - 错误的使用语义标签也会给机器的搜索带来问题，也会给我们css的编码带来负担

      - 我们作为前端要争取用对语义化的标签，有的时候没有标签甚至会出现问题

      - 应用场景

        - 核心：html 编码的最后会形成一个文档树，而标签的语义就是关键

        - 自然语言表达能力的补充；

        - 文章标题摘要；

        - 适合机器阅读的整体结构。

    - 标签的实际使用--在wiki中

      - 引用

      - 文章结构

      - 例子

      - 代码

      - 英文语法

    - CSS

      - 技术结构
        - CSS 的顶层样式表由两种规则组成的规则列表构成，一种被称为 at-rule，也就是 at 规则，另一种是 qualified rule，也就是普通规则。

      - @规则

        - charset

          - 用来定义编码方式

          - 需要定义在css文件的头部

        - import

          - 可以导入一个css文件

          - 导入的内容不包括 @charset的内容

        - media
          - 这个属性可以实现设备属性的查找，可以让我们实现根据不同的页面环境引入不同的css文件---可以提高不同设备的浏览体验

        - page
          - page 用于分页媒体访问网页时的表现设置，页面是一种特殊的盒模型结构，除了页面本身，还可以设置它周围的盒。---这里不是很清楚怎么使用

        - counter-style
          - counter-style 产生一种数据，用于定义列表项的表现。

        - keyframes
          - 定义动画的关键帧

        - fontface
          - fontface 用于定义一种字体，icon font 技术就是利用这个特性来实现的。

        - supports
          - support 检查环境的特性，它与 media 比较类似。

        - namespace
          - 用于跟 XML 命名空间配合的一个规则，表示内部的 CSS 选择器全都带上特定命名空间。

        - viewport
          - 用于设置视口的一些特性，目前多数时候被 html 的 meta 代替

        - 

      - 普通规则

        - 选择器
          - ![img](https://api2.mubu.com/v3/document_image/6abbe95c-49c9-427a-afee-165b0be99bf4-13258694.jpg)

        - 声明列表

          - 属性

            - 中划线

            - 下划线

            - 字母

          - 值

            - 值的类型
              - 一般的类型都是支持的，要看具体的属性

            - 函数

              - calc()

                - 支持基本的四则运算

                - 在对维度进行运算的时候，支持不同的单位进行混合运算

              - max()

              - min()

              - clamp()--超出范围使用最大或者最小值

              - toggle()--表示两种效果之间的切换

              - attr()--允许 CSS 接受属性值的控制

  - 算法

    - \1. [380. O(1) 时间插入、删除和获取随机元素](https://leetcode.cn/problems/insert-delete-getrandom-o1/)
      - 关键是结合数组末尾删除元素与哈希表查找值的性质![img](https://api2.mubu.com/v3/document_image/36b0a4cf-c4fa-4594-ba7c-2cc0c2a43807-13258694.jpg)

    - \2. [710. 黑名单中的随机数](https://leetcode.cn/problems/random-pick-with-blacklist/)

      - ![img](https://api2.mubu.com/v3/document_image/dae21c16-f9b2-45c7-9f49-e743f6f70ea5-13258694.jpg)

      - 这题的难度其实在于思维，要将黑名单这个概念转化为哈希映射一般情况下是很难想到的

      - 实现关键

        - \1. 最后是在除去黑名单的数组中进行随机选取，所以 len = n - blacklist.length

        - \2. 在将黑名单中的数字映射到没有黑名单的数字的时候需要注意，我们映射到的位置不能存在于黑名单中

        - 3.大于我们随机选取范围的数就不必在第一步中进行映射了，因为它不会存在于我们映射完成后的数组

  - vue3

    - 今天复习电路，加上在算法上花的事件比想象中的多了一点，没有学。

    - 明天一定

- 第五天

  - 算法

    - 开始二叉树

      - 三个遍历需要注意的点

        - 前序遍历只能够拿到父元素传入的值

        - 后序遍历中不仅能够拿到父元素传入的值，还能够拿到子节点传上来的值，可以做更多事情

      - 题目
        - ![img](https://api2.mubu.com/v3/document_image/11ecafed-3ea7-4619-931c-f49c211588b6-13258694.jpg)

  - 重学前端

    - 浏览器的工作原理

      - 工作流程

        - 浏览器首先使用 HTTP 协议或者 HTTPS 协议，向服务端请求页面；

        - 把请求回来的 HTML 代码经过解析，构建成 DOM 树；

        - 计算 DOM 树上的 CSS 属性；

        - 最后根据 CSS 属性对元素逐个进行渲染，得到内存中的位图；

        - 一个可选的步骤是对位图进行合成，这会极大地增加后续绘制的速度；

        - 合成之后，再绘制到界面上。

        - 图片![img](https://api2.mubu.com/v3/document_image/0ed0eba4-971f-4b08-9712-d3ce5ab21d4a-13258694.jpg)

      - HTTP

        - 概况

          - 首先，这是一个网络协议，也是我们学习计算机必须迈过去的坎

          - 基于TCP，需要三次握手，而HTTP在每次连接中都需要request和response

          - HTTP3.0是基于tcp协议实现，更快。

        - 返回数据的格式
          - ![img](https://api2.mubu.com/v3/document_image/b4a96383-b567-4d7e-9926-8698c0af22a4-13258694.jpg)

        - 方法

          - GET--请求

          - POST--携带数据的请求

          - HEAD--只获取请求头

          - PUT--向服务端请求增加数据

          - DELETE--向服务端请求删除数据

          - CONNECT--多用于https和websocket

          - OPTIONS和TRACE--大多用于调试，线上模式一般不支持

        - 状态码

          - 1xx：临时回应，表示客户端请继续。

          - 2xx：请求成功。
            - 200：请求成功。

          - 3xx: 表示请求的目标有变化，希望客户端进一步处理。

            - 301&302：永久性与临时性跳转。

            - 304：跟客户端缓存没有更新。

          - 4xx：客户端请求错误。

            - 403：无权限。

            - 404：表示请求的页面不存在。

            - 418：It’s a teapot. 这是一个彩蛋，来自 ietf 的一个愚人节玩笑。（[超文本咖啡壶控制协议](https://tools.ietf.org/html/rfc2324)）

          - 5xx：服务端请求错误。

            - 500：服务端错误。

            - 503：服务端暂时性错误，可以一会再试。

        - HTTP Header

          - Request Header
            - ![img](https://api2.mubu.com/v3/document_image/d6afe995-b2a0-455c-b48c-d08d3c1fba62-13258694.jpg)

          - Response Header
            - ![img](https://api2.mubu.com/v3/document_image/c652c2a6-6a87-419f-988b-10d9db106cb2-13258694.jpg)

        - HTTP Request Body

          - application/json

          - application/x-www-form-urlencoded

          - multipart/form-data

          - text/xml

      - HTTPS

        - 主要起到的作用是确认客户端身份和保证数据不会被中间节点窃听或修改

        - 原理是基于TLS（一个传输加密协议），而它本身又是基于tcp的，所以本质上传输的内容并没有区别

      - HTTP2

        - 1.支持服务端推送

        - \2. 支持TCP连接复用

  - Vue3

    - 事件

      - event modifiers

        - .stop --- the event's propagation will be stopped 

        - .prevent--- to prevent the default events

        - .self  --- only trigger handler if the event.target is the element itself
          - Order matters when using modifiers because the relevant code is generated in the same order. Therefore using @click.prevent.self will prevent clicks default action on the element itself and its children while @click.self.prevent will only prevent clicks default action on the element itself.

        - .once -- obviously , can be trigger only once

        - .passive 

          - -- to trigger the event immediately instead waiting for 'on scroll will happen'

          - The .passive modifier is typically used with touch event listeners for [improving performance on mobile devices](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#improving_scrolling_performance_with_passive_listeners).

        - .capture

      - key modifier
        - @keyup.anyValidKeyEvent.key

      - key alias

        - .enter

        - .tab

        - .delete (captures both "Delete" and "Backspace" keys)

        - .esc

        - .space

        - .up

        - .down

        - .left

        - .right

      - system modifier keys

        - .ctrl

        - .alt

        - .shift

        - .meta

        - these modifier only can be triggered when release the other keys while pressing these key ,such as ctrl + enter

        - The .exact modifier allows control of the exact combination of system modifiers needed to trigger an event.

      - Mouse Button Modifier

        - .left

        - .right

        - .middle

      - 

    - Form Input Binding

      - <input> with text types and <textarea> elements use value property and input event;

      - <input type="checkbox"> and <input type="radio"> use checked property and change event;

      - <select> use value as a prop and change as an event.

      - these label can bind the checked value by value = .. and can get by v-model

    - Lifecycle Hooks

      - the most used hooks are mounted updated unmounted

      - 

    - 组件基础

      - 可以在子组件上通过自定义事件实现 v-model
        - 原理是使用事件抛出数值来实现

      - 可以使用插槽来接收并展示父组件放在子组件标签中的内容

- 第六天

  - 重学前端

    - 浏览器的工作原理

      - 浏览器接收到一个html文件的时候如何进行解析----这一篇主要是编译原理了

        - ![img](https://api2.mubu.com/v3/document_image/9efeb314-20c9-4e94-88c9-41442f41559a-13258694.jpg)

        - \1. 进行词法分析

          - 这一步是将字符串拆分成一个个token

          - 一般是基于状态机实现

          - 拆词方法---标签是成对出现的![img](https://api2.mubu.com/v3/document_image/cc39125a-a574-4423-bf52-71f4c56211f8-13258694.jpg)

          - 状态机，就是接收到的不同的字符，这个字符对象转换到不同的状态(data  tag tagopen tagclose etc..)![img](https://api2.mubu.com/v3/document_image/7b5fa4d6-e66f-4d96-a87e-ead14e8a8f7c-13258694.jpg)

          - 这里还有一个点：正则就是使用状态机实现的

        - \2. 通过栈来构建DOM树

          - 先用栈将前面解析出来的TOKEN(有序的)存起来

          - 通过标签之间的关系，使用栈构造DOM树

            - 具体过程

              - 栈顶元素就是当前节点；

              - 遇到属性，就添加到当前节点；

              - 遇到文本节点，如果当前节点是文本节点，则跟文本节点合并，否则入栈成为当前节点的子节点；

              - 遇到注释节点，作为当前节点的子节点；

              - 遇到 tag start 就入栈一个节点，当前节点就是这个节点的父节点；

              - 遇到 tag end 就出栈一个节点（还可以检查是否匹配）。

      - 浏览器给DOM树加上CSS属性

  - 算法部分
    - 继续二叉树
      - ![img](https://api2.mubu.com/v3/document_image/a9aaf5dc-88c8-4a90-bd3e-1597150c6ef1-13258694.jpg)

  - vue3

    - 深入组件

      - 组件注册

        - 命名风格

          - \1. 小写

          - \2. 不同单词之间使用 -进行分隔

          - 目的：不和原生 HTML 元素发生冲突，而大写的命名在有的情况也会转为小写。

        - 注册

          - 1.使用 app.components('name' , {content})的方法进行全局注册

          - \2. 将组件定义在另外一个文件夹中，通过 创建vm时的 components属性在组件中进行注册
            - 一般需要导入，然后再注册

      - Prop类型

        - 1.我们使用Prop属性来接收父元素向子元素传递的数据

        - \2. 在父元素中通过标签属性来给子元素传递数据，默认情况下传递过去的都是字符串形式的数据，如果需要其它格式，那么就需要使用v-bind的形式来向子元素传递数据
          - 这里在传递对象的时候会将对象解构为它的属性，再进行传输

        - \3. 子元素在接收数据的时候可以自定义接收规则

          - js中的基本类型都在判定的范围之内
            - 具体来说是根据构造函数来进行判定，通过判定是否存在相应的构造项来进行类型判定

          - 可以定义 valid函数来判定数据的有效性

          - 定义default 来返回默认值
            - 这里需要注意对象类型的数据返回的时候需要工厂函数default (){ return ...};

        - \3. 单向数据传输原则

          - 1.因为是父组件向子组件发送数据，所以当父组件数据改变的时候子组件中的数据会同步改变。

          - \2. 基于1，我们要避免在子组件中修改父组件传递的数据，防止错误。

          - \3. 注意js中的所有类型都是引用类型，在子组件中的修改是会同步到父组件中的，容易发生不可控的错误。

      - 非Prop 的属性传递--没有被Prop接收的数据传递

        -  属性 和 事件函数

          - 这些属性可以在子组件的实例上通过$attr属性访问到，所有的属性包括方法都会传递到上面

          - 如果没有指定Prop进行接收，那么我们传递的属性会直接绑定到子组件的根元素上

          - 如果不是多个根节点的组件，那么我们绑定的事件处理函数会隐式的传递到有对应事件的元素上，比如为change事件传递的函数会响应到select的变化

        - 可以通过组件属性中的inheritAttrs: false声明来禁用默认绑定root元素，所有传递的属性依然可以在组件属性中访问到

- 第七天

  - 算法

    - 二叉树的构造

      - 二叉树的构造问题一般都是使用「分解问题」的思路：构造整棵树 = 根节点 + 构造左子树 + 构造右子树。先找出根节点，然后根据根节点的值找到左右子树的元素，进而递归构建出左右子树。

      - 题目练习![img](https://api2.mubu.com/v3/document_image/4948da3b-5c17-4608-b963-a5545e80f9b5-13258694.jpg)

  - Vue3

    - 深入组件

      - 自定义事件

        - 命名
          - 依然建议使用kabel-name;

        - $emit使用它来声明自定义函数emit:[]使用这个数组来接受组件中定义的自定义函数
          - emit:[]可以写成emit:{}对象的形式，里面将属性写成工厂函数的形式，就可以进行格式的限定
            - 具体的是通过函数流程来判断数据是否有效，返回true or false作为结果

        - v-model

          - 我们可以通过prop和emit两个属性的配合来实现组件之间的v-model，也能实现绑定多个v-model

            - \1. 在父组件中使用v-model

            - \2. 在子组件中定义prop接受数据，通过定义update:value-name来指定自定义函数，来进行数据的响应

            - ps：这里定义的函数名应该是官方提供的，文档中没有给实现

        - v-model 修饰符

          - 我们可以通过prop 来接收我们定义的修饰符，其中如果是带参数的，接受的名称为argv+name

          - 然后就可以在method中对我们的修饰符方法进行定义

          - 执行方法之后通过调用$emit(update:value-name,updated-value)方法进行更新

        - 

- 第八天

  - 算法

    - 二叉树的序列化和反序列化

      - 主要就是之前的遍历和构造结合起来

      - 注意点：构造的时候能拿到的只有一次遍历的结果，要借助null指针的位置来确定二叉树

  - 重学前端

    - 浏览器

      - css的渲染

        - 排版

          - 正常流

            - inline

            - inline-box

            - box

            - float

            - position

          - flex

          - grid

        - 渲染

          - 这里指的是将我们排版好的元素转化为计算机中的位图

          - 一般情况下不会直接按顺序渲染所有元素，因为需要考虑性能，减少重绘的次数，而当我们渲染好的部分出现js的操作时，都会进行重绘

        - 合成

          - 这个步骤主要是针对渲染做的优化

          - 原则是最少重绘

          - 执行的时候也就是将我们可能操作的元素先不渲染，将那些重绘可能性较低的元素先渲染。这样就减少了我们的重绘次数

          - 在css标准中有will-change属性，来指定我们合成的元素，如果合成命中效果好的话，可以大大提高我们的页面性能

        - 绘制

          - 也就是将前面渲染出来的位图绘制到页面中的过程，一般这一步是由操作系统或者显示驱动来完成，浏览器只需要将我们绘制的位图交给他们就行

          - 绘制的过程中可能会面临各种交互，都会触发重绘。解决这种问题的方法在计算机图形学中叫脏矩形。也就是将显示区域划分为一个个矩形，当触发事件的时候只重回事件周围相关矩形，减少重绘的量。

    - HTML

      - 元信息标签

        - head
          - 是元信息的容器，一般的原信息都写在这里面

        - title
          - 和h1有区别，场景是被搜索引擎当作单独的卡片词条显示，所以一般要包含页面的大致信息。

        - base

          - 可以设置页面的http地址，可能会影响和js的配合

          - 一般这个标签的功能由js来实现

        - meta

          - 一般是一组<meta name="xxx"   content="xxx">的键值对标签，给页面的元信息添加对应的属性，也有可执行的命令

          - 一些约定的meta

            - charset

              - 用于指定页面的编码格式

              - 一般情况下浏览器会根据http头来进行判断，但是在其它协议中可能没有判断，这时候这个信息就很关键了

            - viewport

              - 用于表示页面的浏览终端

              - 可以指定页面对终端的高度、宽度、缩放等

              - <meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no">

            - http-equiv

              - 可以在标签中执行一些命令

                - content-language 指定内容的语言；

                - default-style 指定默认样式表；

                - refresh 刷新；

                - set-cookie 模拟 http 头 set-cookie，设置 cookie；

                - x-ua-compatible 模拟 http 头 x-ua-compatible，声明 ua 兼容性；

                - content-security-policy 模拟 http 头 content-security-policy，声明内容安全策略。

              - 例子：  <meta http-equiv="content-type" content="text/html; charset=UTF-8">他就相当于设置了头信息中的content-type

  - 计算机网络--整理复习
    - [计算机网络](https://mubu.com/doc3bhycYr_v00) 

- 第九天

  - 算法
    - 二叉树
      - [652. 寻找重复的子树](https://leetcode.cn/problems/find-duplicate-subtrees/)

  - 计算机网络

    - 计算机网络

    - 更新网络层内容

  - 重学前端

    - js 的执行顺序

      - 宏仁务和微任务

        - 首先要把异步线程和主线程区别开，主线程队列按顺序执行非异步代码，而异步线程执行异步任务，在这里才有任务的区分

        - 宏仁务是宿主环境创建的任务，微任务是js引擎自己创建的任务

        - 微任务和宏仁务交替执行

          - \1. 编译阶段先将任务添加到任务队列中![img](https://api2.mubu.com/v3/document_image/146760d1-6fa4-4344-8512-ad4412e5cb93-13258694.jpg)

          - 2 . 先执行同步任务

          - \3. 执行异步中的微任务

          - 4.执行宏仁务---宏仁务中的任务也是同样的规则

          - \5. 再看微任务队列，执行微任务

          - 6.再执行下一个宏仁务

          - 例子
            - ![img](https://api2.mubu.com/v3/document_image/48e7868c-4e1a-4e2d-aae7-ffb338f756cf-13258694.jpg)

      - Promise

      - async/await

    - 闭包和执行上下文
      - 都是js函数执行时的知识![img](https://api2.mubu.com/v3/document_image/fb381b39-b6ae-4e85-af44-ea02d8f8d600-13258694.jpg)

  - Vue3

    - 深入组件

      - 插槽

        - 插槽最大的作用是为父组件中在标签之间传入的内容指定展示的位置

        - 渲染作用域：父级数据在父级作用域渲染，子级数据在子级作用域中渲染
          - 也就是：直接在插槽中使用父级的元素会出错

        - 插槽Prop

          - 在父级标签中使用v-slot:name='attribute'可以向具名插槽中传递数据

          - 特别的，当组件中只有默认插槽的时候，可以直接将v-slot写在子组件的标签上，插槽名也可以省略，这种方式可以是命名变得很简便

          - 可以传入多个attribute

        - 默认插槽
          - 也就是不指定名字，在子组件中使用<slot></slot>来指定的位置，父组件直接放在子组件中的内容会直接显示在这对标签里

        - 具名插槽

          - 使用template name='xxx'这样的方式来给插槽指定名称，可以方便父组件向子组件中传递不同的内容

          - name可以简写为# 使用，如：#name

        - 需要注意的是，插槽传入数据在实现上是使用函数传参，也就意味着只要符合函数传参的规则，我们都可以传入作为参数
          - 对象的解构赋值{item:todo}，可以使用对象解构赋值的重命名方法

      - Provide/inject

        - 我们可以将它看作一个远程的Prop，不过父组件不知道数据传给谁，而子组件也不知道数据来自哪里

        - 使用

          - \1. 父组件中使用provide:{ 数据 }的方式来提供数据，但是当我们想要提供一个对象类型的数据时，我们需要将provide写成返回函数的形式，如provide(){return {key:value}}这样的方式来进行使用

          - \2. 子组件中使用inject:['name']的方式来进行接收，然后就可以在组件中进行使用了

      - 动态组件和异步组件

        - keep-alive ,可以让我们的组件在切换的时候不被销毁

        - defineAsyncComponent 方法，可以让我们定义一个异步组件

          - \1. 可以配合工厂函数和webpack 、babel 直接导入注册

          - \2. 如果需要和<suspense>配合使用，需要注意它会成为父组件中标签的异步依赖，自己的状态受父组件控制，当然，可以通过suspensiable:false取消

      - 模板引用

        - 需要注意的是，这种做法官方并不推荐

        - 可以给元素定义一个ref=name的属性，然后我们可以在this.$ref.name中进行访问，比如我们需要页面挂载完成就让焦点集中在输入框上，就可以使用这个属性来绑定输入框，以调用focus方法

        - 我们也可以通过个子组件绑定ref，在父组件中调用子组件的方法

      - 强制更新/静态渲染

        - 当我们发现页面不能更新了（大部分情况下是出了问题），我们可以调用$forceUpdate来进行强制刷新

        - 当我们有大量的静态内容需要渲染的时候，可以使用v-once指令进行渲染，这样它不会改变，且会有缓存

    - 过渡/动画

      - 概述

        - vue中可以使用css中定义的动画，通过class的绑定来实现

        - vue也为我们提供了<transition>过渡标签，让我们能够更好的结合vue中提供的一些内置属性和第三方库来进行动画的制作

      - 进入/离开 过渡

        - 单元素/组件 的过渡

          - 这里单元素和组件的实现过程基本相同

          - css过渡，通过定义@keyframes or transfrom or animation来进行动画的定义，一般在元素进入或者离开的时候生效。

          - 使用vue内置的transition过渡标签，通过给标签命名，然后在css中定义对应的动画，我们就可以通过这个标签来实现动画效果啦

            - v-enter-from v-leave-from v-enter-to v-leave-to这四个属性分别定义了动画开始前和动画结束后的状态

            - v-enter-active v-leave-active分别定义了进入和离开过程的动画

          - js钩子

            - 我们可以将在过渡标签中通过前面定义的六个阶段，vue将它们转化为了可触发的事件，我们可以通过绑定这六个事件来定义动画的js函数，能够帮助我们完成更为复杂的动画效果

            - 另外，我们也可以通过这些钩子来更方便的配合第三方的库来定义动画

          - 初始渲染的过渡
            - 可以通过<transition appear> appear属性来定义初始渲染的动画

          - 多个元素之间的过渡
            - 我们可以在transition标签中包裹组件或者多个元素，配合v-if or v-show来实现多个元素之间的过渡

          - 过渡模式

            - in-out: 新元素先进行进入过渡，完成之后当前元素过渡离开。

            - out-in: 当前元素先进行离开过渡，完成之后新元素过渡进入。

          - 多个组件之间的过渡
            - 可以直接使用过渡标签包裹动态组件标签就可以实现过渡

        - 列表过渡

          - 一些注意点

            - 列表过渡需要包裹在transition-group标签中，默认情况下它不会渲染一个包裹元素，我们可以指定一个tag属性来标明需要渲染的元素

            - 内部元素需要指定唯一key值

            - 过渡模式不可用，因为我们不需要两个元素之间的切换，这里是多个元素之间的切换

          - 列表的进入/离开过渡

            - 这里讨论的是当我们渲染多个元素，如使用v-for的时候，如何制作多个元素之间的动画

            - vue提供了基于FLIP技术的动画，可以使用新加入的v-move类来实现多个元素相对位置的平滑过渡
              - 注意：过渡的元素不能是inline的显示模式，可以将他们转化为inline-box或者加入flex布局中

          - 交错过渡
            - 我们可以将动画过渡和js结合起来，实现交错过渡的效果
              - 例子：搜索的候选项

          - 可复用的过渡
            - 我们想要封装一个可复用的过渡的话，根元素内直接使用transition-group 包裹，然后定义对应的动画效果就好了

          - 动态过渡
            - 我们可以在过渡中使用js钩子，这样我们就可以在js中根据传入数据的不同来定义不同的动画效果啦！

- 第十天

  - 算法
    - 略摆，就写了道归并，有几道关联的题目明天写

  - 重学前端

- 第十一天

  - vue3

    - 动画

      - 状态过渡

        - 前面的列表过渡主要是针对元素的创建和销毁，而元素本身状态的变化就需要状态过渡来实现

        - 核心就是将状态转化为可以监视的数据，通过watch来进行监视，再在数据变化的时候加上相应的动效就OK

        - 我们还可以通过对图片的状态的定义，制作具有简单的交互性的动画！

    - 组合式API

      - 核心在于将实现一个逻辑功能的所有代码集合在一块，便于开发大型应用

      - 常用组合式API

        - setup

          - 创建在组件创建之前，当Props 加载完成之后，setup函数就已经创建完毕了

          - 我们可以在这个函数中直接创建变量，创建函数，使用我们之前熟知的watch computed lifeCycleHooks这些api

          - 最后返回我们想要暴露的部分

          - 整体很像使用对象和构建对象方法来实现一个功能

        - watch
          - watch(name,callback(newVal,oldVal))通过这个api在setup函数中调用我们的watch函数

        - lifeCycleHooks
          - onhooks相对于我们之前使用的钩子，这里的钩子前加上了on，如onMounted这个函数就代表着我们的mounted函数，其他的函数格式类似

        - computed
          - let var = computed(()=>{计算部分})使用赋值的方式来声明一个计算属性，并通过箭头函数来编写我们的计算逻辑，并返回计算结果

        - ref / reactive 
          - 用于创建一个数据包裹对象，实现响应式的数据

      - API详细说明

        - setup(prop,context)

          - 参数

            - props
              - 这里需要注意的是，props是响应式的，我们不应该直接对它使用对象的解构语法。可以使用toref方法来进行对象的解构，这样能够保证数据的响应式

            - context

              - 这里的context本身是一个普通对象，可以使用解构语法获取里面的值.它包含了我们能够在setup中使用的内置方法

              - 内容

                - attr

                - emit

                - slot

                - expose

              - 内容中包含的方法使用效果和选项式API基本相同

          - 访问属性

            - 如果setup返回了一些数据，那么这些数据以及setup接收到的prop都可以在模板语法中访问到

            - 返回的属性是浅拷贝的ref，可以直接访问而不用.value，但是嵌套的属性还是需要.value的方式进行访问

          - 渲染函数

            - setup还可以直接返回一个渲染函数，但是这样就无法再返回其它东西了

            - 相对应的，我们可以使用expose方法来返回想要暴露的属性

          - this
            - setup中的this不是指向组件实例，不要乱用

        - provide / inject

          - provide
            - provide(name,val)这里的name必须是string类型，val任意

          - inject
            - inject(name,defaultVal)可以指定第二个参数来赋默认值

          - 响应式
            - 使用ref or reactive来进行数据的响应式包装

          - 修改数据

            - 这里的原则和使用prop相同，尽量不要在inject的组件中进行修改

            - 如果需要修改，可以使用传递函数的方式来进行修改

            - 可以使用readonly方法来实现只读，不允许inject组件修改

    - MIXIN

      - 这算是一种抽象出可重用方法的工具

      - 可以在一个js文件中创建选项式的API，然后通过mixin:['name']的方式导入到我们的组件中，和我们的组件选项进行合并

      - 合并优先级：冲突时组件属性优先，其它情况为合并

      - 特殊情况：自定义选项

        - 自定义选项默认是通过简单覆盖的方式进行合并

        - 可以自定义合并方法

      - 缺点

        - \1. 容易冲突

        - \2. 不能动态传入参数对逻辑进行修改

    - 自定义指令

      - 可以使用app.directive('name',(el,binding){})的方式来进行指令的定义

        - 其中el是指绑定的元素，我们可以从它身上操纵常用的dom属性

        - binding是我们绑定元素时候的属性

          - value 表示我们在使用指令时候传入的属性值

          - arg 表示我们在使用指令时传入的动态参数值

        - 可以在定义的函数内部调用生命周期函数，这里的生命周期对应的是元素的生命周期

        - 生命周期钩子在不声明的情况下，默认是updated 和 mounted两个生命周期

      - 在父组件中对子组件使用自定义指令的时候默认是作用在子组件的根节点，这样也就意味着对多根节点的子组件无效

    - teleport

      - 就和它的字面意思一样，传送。它的作用是将我们的元素渲染到指定的位置

      - <teleport to='目标位置'> 内容</teleport>将内容渲染到目标位置

      - 内容可以是组件，这样会形成父子组件的嵌套关系。

    - 

  - 重学前端

    - js执行--函数相关

      - 闭包

        - 实际上就是包含着一块作用域的函数，在函数内部能够引用作用域外部的量

        - 需要注意的是，实际编码中，我们定义函数的操作可能会导致执行上下文的切换（也就是作用域的切换），导致不能出现预期的效果

      - this

        - 这里需要了解函数，js中的函数有很多，对应的this也不同

          - 普通函数

          - 对象

          - 类 

          - 异步函数  

          - 箭头函数--没有作用域，会向外查找this

        - js中的this是通过一个私有属性来进行定义的，里面存放着函数每次调用时候的状态信息，内部是通过栈和链表实现

      - new 关键字

        - new关键字在不同的函数环境中产生的效果也是不一样的

        - 只能new 有原型的函数，因为需要返回对象

      - 语句

        - 1![img](https://api2.mubu.com/v3/document_image/7c2081a3-b67a-49e3-9ad3-e243ad5a4aef-13258694.jpg)

        - implentation 语句

          - Completion Record 表示一个语句执行完之后的结果，它有三个字段：

          - [[type]] 表示完成的类型，有 break continue return throw 和 normal 几种类型；

          - [[value]] 表示语句的返回值，如果语句没有，则是 empty；

          - [[target]] 表示语句的目标，通常是一个 JavaScript 标签（标签在后文会有介绍）。

        - ![img](https://api2.mubu.com/v3/document_image/b4c8afb5-2240-48f3-965b-f110b844acc3-13258694.jpg)

      - 这些都是一些语言原理方面的知识了

  - 算法

    - 用java写了[327. 区间和的个数](https://leetcode.cn/problems/count-of-range-sum/)

    - 总的来说，还是比较难的---主要是难写

  - 网络

    - 复习传输层内容

    - 传输层

- 第十二天

  - 算法

    - 二叉搜索树

      - [1038. 从二叉搜索树到更大和树](https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/)

      - 过两天考高数了，暂时不挑战高难度的题目

  - 重学前端

    - CSS选择器

      - 这里在使用选择器的时候，还要考虑命名空间的问题--比如svg和html中都有a，选择的时候就需要标明命名空间![img](https://api2.mubu.com/v3/document_image/0b1ada16-30ae-4d85-aa33-9c94557c908a-13258694.jpg)

      - 

  - 网络

    - 应用层

      - DNS域名系统--端口号53

        - DNS是一个分布式的数据库，保存着主机名到IP的映射

          - 分布式是指每个站点只保存它自己的那一部分数据库

          - 域名具有层次结构
            - ![img](https://api2.mubu.com/v3/document_image/8bedf7a3-9215-43a8-acfe-f293fdc361ac-13258694.jpg)

          - DNS使用TCP或者UDP来进行传输，一般是UDP,使用的端口号都是53

            - 一般情况下使用的是UDP进行传输，要求域名解析器和域名服务器自己处理超时和重传，以确保稳定。

            - 有几种情况会使用TCP进行传输

              - 如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。--大小

              - 区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。-- 维护

      - 文件传输FTP

        - 使用TCP进行传输

        - 有两种连接

          - 控制连接
            - 用来建立连接

          - 数据连接
            - 传输数据

        - 两种连接模式

          - 主动模式

            - 服务端主动给客户端推送数据，服务端的端口号为20，客户端的端口随机，但是必须大于1024，因为0-1023是熟知端口

            - ![img](https://api2.mubu.com/v3/document_image/0f50047d-ea08-439c-a4d0-daf3c18cdc8b-13258694.jpg)

          - 被动模式

            - 客户端主动建立连接，这时候客户端的端口由客户端指定，服务端的端口随机

            - ![img](https://api2.mubu.com/v3/document_image/76e427aa-6301-4a61-95a8-380d879c85ed-13258694.jpg)

          - 主动模式需要为客户端配置防火墙设置，被动模式则不需要，但是会降低服务端的安全性，因为暴露了过多的端口号

      - 动态主机配置协议(Dynamic Host Configuration Protocol)

        - 可以让用户不用自己配置IP

        - 包括IP，子网掩码和网关地址

        - 具体过程

          - 其中discover报文应该是固定的：目的地址为255.255.255.255.67，源地址是：0.0.0.0.68，通过UDP向网络中广播发送，如果需要进入其他网络，还需要中继![img](https://api2.mubu.com/v3/document_image/f39f01f9-8555-463b-a608-dcc9641aef73-13258694.jpg)

          - 请求都是通过广播的方式进行发送

      - 远程登陆协议TELNET

        - 是TCP/IP协议的子族协议

        - 以虚拟终端机的形式提供双向的，以字符串信息为主的命令行式的交互服务

        - 应用于远程登陆，可以在客户端运行服务端的工作（通过网络）

      - 电子邮件协议

        - SMTP

          - 基于TCP，也就有握手的过程

          - 常用于发送邮件

          - 只能发送7位ASCII码，不支持多国语言，且邮件超过一定长度会被拒收

          - MIME协议：可以看作是SMTP的补丁，让SMTP能够发送二进制和其它格式的数据---使得邮件的内容更加丰富多彩

        - POP3邮局协议
          - POP3主要用于邮件读取，特点是只要用户读取了邮件，就将邮件从服务端删除。但是最新版的协议不允许删除。

        - IMAP
          - 用于维持客户端和服务端的同步，当客户端删除邮件之后，服务端才会删除。可以保证客户端可以随时随地访问服务端上的邮件

      - 常用端口

      - web响应请求的过程

        - 1.DHCP ---请求分配IP地址

        - \2. ARP ---找到网关路由器的MAC地址

        - \3. DNS ---获取域名IP

        - \4. HTTP --- 通过建立HTTP连接来进行数据传输，得到页面数据之后Web浏览器会进行渲染，得到最终页面

- 第十三天

  - 算法

    - BTS

      - 判断一棵树是否是二叉搜索树

        - 要注意的是，二叉搜索树的左边的所有元素都要比右边的小才行

          - 可以通过限制根节点的值来进行判断

          - 也可以通过二叉搜索树的中序遍历的性质来进行判断

      - 搜索

  - 重学前端

    - css选择器和伪类元素

      - 复杂选择器

        - 复杂选择器由复合选择器构成，而符合选择器又由简单选择器组成

        - 优先级

          - 第一优先级：无连接符号

          - 第二优先级

            - \> 
              - 选择子级元素

            - ~
              - 所有后继节点

            - || 
              - 列选择器，表示选择对应列中符合条件的单元格

            - +
              - 直接后继节点，相当于nextSibling的用法

          - 第三优先级
            - ,
              - 表示并列

      - 优先级

        - css中有一套避免选择到同一个元素时样式冲突的规则

          - \1. 后面的代码覆盖前面的

          - \2. 不同选择器的优先级不同

            - id选择器为1级

            - 伪类选择器和class选择器为2级

            - 伪元素和标签选择器为3级

            - 通过进制来进行分级

      - 伪元素

        - ::first-line

        - ::first-letter

        - ::before

        - ::after

        - ![img](https://api2.mubu.com/v3/document_image/b9771d56-53de-4f0d-ab1d-96830caf40e9-13258694.jpg)

  - vue3

    - 渲染函数

      - 概要

        - vue中是使用虚拟DOM来进行DOM的渲染

        - 使用render(){ return {'name | string' , {props...，元素标签内的属性} , VNodes | 子元素，可以是数组 }，渲染函数就是DOM的构建核心，而声明式的语法也会在编译的时候转化为指令式的语法

        - 使用渲染函数的优点是我们可以使用完全的js语法进行渲染，可以实现更为简洁-复杂的逻辑

      - 唯一Vnode

        - 使用渲染函数渲染的时候必须保证我们直接渲染的节点和子节点都是唯一的，否则会起冲突

        - 需要渲染多个相同标签的时候可以使用工厂函数

      - 其他的用法都是基于声明式写法的转换，需要用到的时候再详细学习----指令太多了

    - 插件

      - 编写

      - 使用

    - 高阶部分---目前是了解，暂时用不到
      - 

  - 网络复习

    - 网络各层之间是有联系的，可以通过一个web响应的过程来整体理解

    - 下层的数据包含上层

- 第十四天--6.24

  - 算法
    - 二叉搜索树的增删改查

  - vue3

    - 深入

      - 响应式的原理

        - 不看具体实现，就是将vue中数据和render函数都使用Proxy()函数包裹，并使用一个track函数来进行追踪setter，定义trigger函数来响应setter并触发重新渲染

        - 其中Proxy的代理是可以嵌套的，这样就形成了vue3中的响应式。

      - 响应式API

        - 形成响应式的数据：reactive() ref()

          - 其中ref()一般用来包裹基本类型，string number bool可以，对象和数组这一类可能有嵌套关系的不行，使用ref()包裹的数据可以直接在模板中使用

          - reactive()则是用来包裹嵌套类型的数据，它会给对象中的所有属性加上代理，属于深拷贝。它的使用需要加上.value进行访问。

        - 监听：watchEffect(()=>{},{flush: sync | pre | post}) watch(()=>{这个函数是getter},(newVal,oldVal))

          - effect

            - 和watch不同的是，它作用于整个组件，当组件中的任何一个响应式数据发生变化的时候都会触发这个函数中的回调

            - 可以通过接收它的返回来取消一个effect监听，也可以通过一个oninvalidate函数来在effect未执行完毕的时候就将它取消，常用于异步请求（如promise）的时候，而vue也依赖于异步请求返回的promise中的数据来正常运作。

            - 在进行依赖的监听的时候，可以使用onTrack 和 onTrigger两个API来对依赖关系进行验证和调试。

          - watch

            - 和effect相比起来，它能够对监听做一些更具体的操作，如指定监听对象、懒加载、获取改变前后的值。

            - 监听嵌套对象的时候同样需要指定deep:true，也可以使用flush来设置生效的时机。

      - 渲染机制和优化
        - 虚拟DOM

      - vue2中响应式的一些限制

        - \1. 不能在根数据节点，也就是data()之外动态的给其中声明的对象添加属性，这样添加的属性会失去响应式。

        - 2 . 变化缓存，vue会将页面的改变存入一个队列中，当一次操作执行完毕之后再进行更新，而有时候我们需要让他立刻有效果，那么我们可以使用$nextTick()函数，它会在数据变化时立即执行。这个函数也可以使用async/await来处理，因为它的返回值是一个pormise对象。

        - \3. 数组方法，一些数组方法不能在vue2中使用---☞响应式

    - 工具

      - 单文件组件
        - SFC格式，也就是.vue文件中的三个部分。

      - 测试

        - 单元测试

        - 端到端测试

        - 都需要一个好的断言库和测试工具，有推荐。

    - TypeScript支持

      - 整个vue3都是使用它编写的，有良好的支持

      - 

- 第十五天--6.25

  - 明天考高数，就写个算法

  - 算法
    - 判断完全二叉树的节点个数

- 第十六天--6.26

  - 算法

    - 图论基础

      - dfs，主要的概念是visit path两个数组的使用方法

      - [797. 所有可能的路径](https://leetcode.cn/problems/all-paths-from-source-to-target/)

    - vue3
      - 安全
        - 这里vue文档中提到的漏洞都是注入漏洞，预防的方法就是不要100%的信任用户的代码，除非已经构建了相关的沙盒环境或者用户的代码不能触碰到其他代码。

  - vue3

    - 文档部分完成。

    - 开始学习typeScript

- 第十七天--6.27

  - TypeScript
    - 完成基础类型和泛型的使用

  - 算法
    - [9. 回文数](https://leetcode.cn/problems/palindrome-number/)，今天没时间了，搞道简单题

- 第十八天--6.28

  - TS
    - 学习了泛型和rollup的配置

  - 算法
    - 一道简单题

- 第十九天-6.29

  - 完成ts基础部分的学习

  - 复习移动端和CSS布局

    - viewport

    - 二倍图

- 第二十天6-30

  - 复习移动端布局

    - 流式布局案例---京东移动端页面

    - flex布局

  - 算法
    - 判断单向图是否成环
      - [207. 课程表](https://leetcode.cn/problems/course-schedule/)

- 第二十一天--7.1

  - 高数G了，今天好好复习复变

- 第二十二天--7.2--考完啦

  - 移动端布局
    - flex---携程移动端布局

  - 算法
    - n叉树的层次遍历

  - 网络
    - 点击URL之后的过程

  - vue3

    - 前端的历史

    - vue3的特性

- 第二十三天--7.3

  - 算法
    - LCA -- 构建父亲节点列表+模拟

  - 网络

    - 上层依赖下层实现功能

    - DHCP+FXE

  - vue3
    - 

  - 移动端布局
    - flex--完成携程移动端布局

- 第二十四天--7.4

  - 网络
    - 由寝室联机理解物理层、数据链路层所起到的作用

  - 算法
    - 拓扑排序

  - vue3

    - 学习使用组合式api封装功能函数

    - 封装组件

- 第二十五天--7.5

  - 算法
    - 搜索
      - dfs全排列

  - 官网开发

    - css样式还是要多写才行。。

    - 使用element配合文本编辑器实现新闻页面的编写

- 第二十六天--7.6

  - 网络

    - 路由

    - 两类算法

    - 两个协议

    - 它们之间的优缺点和改进

  - 算法

    - 搜索

      - N皇后

      - 地图类的题目

  - 开发官网
    - 搭最近动态页面的架子

- 第二十七天--7.7

  - 算法
    - 判断最长公共前缀

  - 官网开发
    - 捣鼓了一下md编辑器，但是没搞出来

  - js高级
    - 内存管理

- 第二十八天--7.8

  - js高级

    - 函数式编程

      - 优点、缺点

      - 高阶函数

      - 函数柯里化

    - js异步

      - 进程和线程

      - 同步和异步

      - js中的异步，异步解决的问题，宏任务和微任务的区别和解决的问题。

  - 算法
    - 最短路径

- 第二十九天--7.9

  - 依旧js高级

    - 异步

      - Promise

        - pedding resolve reject

        - resolve()

        - then()

      - Generator

        - .next()，next（）传入参数的作用

        - 封装执行函数

      - rxjs

        - 响应式编程的实现，不止一种编程语言

        - 内置发布订阅模式的实现

      - 观察者--这里vue2给出了优秀的实现

    - 设计模式

      - 目的

        - 帮助我们组织模块

        - 帮助我们设计模块之间的沟通

        - 提高我们的代码质量

          - 可扩展性

          - 可读性

          - 可靠性

          - 可复用性

          - elegent !

      - 原则

        - 开闭原则

        - 单一职责原则

        - 依赖倒置原则

        - 接口隔离原则

        - 迪米特法则

        - 里氏替换原则

      - 分类

        - 构造

          - 工厂

          - 单例

          - 建造者

        - 行为

        - 技巧

          - 桥接

          - 享元

          - 模板方法

          - 其中模板方法类似于类的继承，而js中更推崇组合式，也就是函数式的编程方法。

        - 结构

  - 算法
    - DFS记忆化搜索

- 第三十天 -- 7--10

  - 算法
    - 最短路径-搜索的BFS实现

  - 网络

    - 了解历史

    - 网络分层中的架构思想

  - js高级

    - 设计模式中代码优化的部分

      - 备忘录模式

      - 迭代器模式

      - 策略模式

      - 外观模式

- 第三十一天-- 7-11

  - 算法

    - 二叉堆的实现

    - 使用最小堆来解决k个升序链表的合并问题

  - 网络

    - http协议概述

    - http协议各个状态码，常用状态码

    - 遵循标准的重要性、

- 第三十二天--7-12

  - 算法
    - 用二叉堆配合懒删除解决滑动窗口的最值

  - 网络

    - tcp/udp http2.0 http3.0

    - whistle抓包分析、postman常用功能学习

    - 实战fetch、promise

    - 手写promise

    - 网络请求优化

      - 指数补偿

      - 并发请求

- 第三十三天-- 7-13

  - 学习vim操作方式

    - hjkl

    - 退出

  - 算法
    - 删除二叉搜索树的后继

- 第三十四天 -- 7-14

  - 算法
    - 又回到了二分

  - 网络

    -  了解webSocket，使用webSocketIO库来搭建一个简易的聊天室

    - 缓存

    - 同源策略、常见的网络攻击

    - 状态同步和路由

- 第三十五天 -- 7-15

  - 算法
    - 复习二分，学到了两个更通用的模板

  - 网络
    - 复习TCP/UDP，了解两者在应用上的区别

- 第三十六天 -- 7-16

  - 算法
    - 二分答案

  - 网络

    - 网络性能指标

    - 优化方法

- 第三十七天 -- 7-17

  - 字节青训
    - 刷题

  - 算法
    - 二分答案复习--upper_bound

  - vue
    - vue2响应式源码

- 第三十八天 -- 7-18

  - 算法

    - 学习排序

      - 交换排序

        - 稳定排序

        - 不稳定排序

      - 计数排序

      - 实现

        - 归并 -- 稳定

        - 快排 -- 不稳定

        - 两者的区别 -- 快排在平均情况下比归并节省空间、且更快

  - 前端

    - vue

      - 响应式实现

        - proxy -- vue3的实现

        - bucket -- 存储effect回调函数

        - active -- 全局当前回调
          - js是单线程，每一次对响应式数据的调用都可以触发

        - 用一个weakMap来实现响应式对象的属性和回调之间的对应关系。

    - js

      - weakMap

        - 和普通map的区别在于，键是一个对象，且会被垃圾清理机制清理

        - 不可遍历

- 第三十九天 -- 7-19

  - 算法

    - 计数排序的题

    - 合并区间--使用排序

  - 前端

    - 了解SSR

    - 学习使用vue3+ts构建项目

- 第四十天  -- 7--20

  - 算法

    - 快排应用-- 第k大的数

    - 差分优化 -- 合并区间

  - 前端

    - 跟着ts的教程写项目

      - \1. 项目建模

        - 模型层 -- 建立用户数据模型，其它服务都基于这一层

        - 服务层

          - 登陆 ---- 写到这里，遇到了一个教程里面没有的bug，找了俩小时，G

          - 等后面知道怎么解决了再续上

      - 主要的收获是知道怎样给一个比较大的系统进行分层、建模

      - 知道ts需要的插件🤷‍♂️，还有环境的配置

- 第四十一天 --  7-21

  - 算法
    - 归并应用 -- 翻转对

  - 前端

    - canvas的基本用法

    - 学习vscode的一些快捷键，提高编辑效率

- 第四十二天 7-22

  - 算法
    - 贪心
      - 第一种证明：路径包容性

  - 前端

    - 学习canvas

      - 绘制矩形

      - 8

  - 字节青训营项目

    - 组队、拉人

    - 摸索项目流程

- 第四十三天 7--23

  - 算法
    - 混了一道简单题，签个到

  - 前端

    - 可视化

      - 了解了canvas的基本api的使用和原理

      - 开始学习echarts

    - 青训营课程

      - 了解了CSS执行过程

      - 对IFC BFC Flex Grid 这几种布局有了更深的认识

    - 项目调研

      - 性能指标

      - 性能测试的api 

    - vue3的新写法

      - jsx，配置比较麻烦，但是写起来确实比较舒服

      - ts , 同样，设计类型需要思考，使用的时候就可以少很多麻烦

- 第四十四天 7-24

  - 算法

    - 贪心

      - 决策拓展--往后多考虑两步

        - 买卖股票

        - 跳跃游戏

  - 前端

    - 调研项目

      - 了解了监控系统大致的实现思路

        - 性能

        - 用户

        - 数据处理

    - vue3

    - js

      - 复习let var const 

      - 作用域链

      - 函数作用域  |  局部作用域

      - 垃圾回收的两种方式

        - 标记清理

        - 引用计数 -- 可能会有循环引用的情况

      - 基于GC机制的性能优化

        - 及时清除 -- 设置 null

        - 使用一个隐藏类

        - 创建一个对象池

- 第四十五天  7-25

  - 算法

    - 贪心
      - 邻项交换法

    - 动规

      - 定义

        - 最优子结构

        - 三要素

        - 边界

  - 前端

    - 主要是青训营的内容

      - js编写的几个建议

        - 各司其职

        - 组件封装 --- 要考虑扩展性、可维护性

        - 过程抽象 --- 函数式编程

      - 高阶函数和函数式编程的应用

        - 函数式编程是声明式编程的子类，一般情况下相对命令式编程来说有更好的可拓展性

        - 高阶函数的应用

          - 防抖和节流

          - 迭代器 --- 执行多个函数 

        - 函数式的继承，需要单独继承原型

      - 算法优化

        - 算法能力和开发能力都很重要

        - 在实际编写代码的过程中，要多想想有没有更好的写法

        - 具体的算法要依托具体的场景来进行优化，一些对性能要求比较低的场景就没有必要让代码变得很复杂

    - 闭包和函数

      - 闭包就是函数能够使用声明它的作用域的变量，这一点在函数作用域上体现的更加明显，可以实现私有变量的封装(es6中的类也没有对修饰符的实现)

      - this指向的是函数的执行上下文

      - new 一个函数，实际上是将函数当作构造器来使用，如果不显式return的话，返回的值是一个复制的函数的this（包含原函数的内容）

    - 可视化--学习echarts

      - 基本属性

        - title

        - subtitle

        - tooltip

- 第四十六天 7-26

  - 算法

    - 继续动态规划

      - 路径总数

      - 最长公共子序列 -- 有点烧脑

  - 前端
    - 可视化
      - echarts的常用的5种图表

- 第四十六天  7-27

  - 算法

    - 动规
      - 最长上升子序列

    - 感觉到动规就开始难理解了

  - 前端

    - 可视化
      - 完成echarts的所有常用图表

    - 字节青训项目

      - 明确需求

      - 完成项目分工

      - 明确技术栈

      - 取组名

- 第四十七天 7-28

  - 算法
    - 动态规划练习
      - 跳楼梯

  - 前端
    - 闭包的原理

- 第四十八天 7-29、

  - 算法

    - 动态规划联系
      - 三角形

    - 前端

      - 了解vue原理

        - proxy比object代理更快的原因
          - 在JIT的反向优化过程中proxy更快

        - vue响应式的原理和流程

- 第四十九天 7-30

  - 算法
    - 动态规划练习
      - 最长递增子序列的个数

  - 前端

    - 正则表达式

    - 写监控项目

      - 封装前端SDK

      - 使用阿里云SLS服务